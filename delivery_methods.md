[[!meta title="Change Notification Delivery Methods"]]
<!--- vim: sw=4 ts=4 tw=80 et -->
<!--- -*- coding: utf-8 -*- -->

# Introduction

This section describes all of the methods by which change notifications may be
delivered to servers.

Chane notifications—generated by the Expander—are picked up from the queue by
workers, where each change-delivery method has its own workers.

Each worker has its own section below, and includes the following information:

* **An Introduction**.

* **Protocol Description**: A description on how the underlying service or
  protocol works.  This section also describes how many parties are involved in
  a single notification.

* **Message Format**: A description of how change notifications are formatted
  when using this delivery method.

* **Sender Authentication**: This describes how the recipient knows they are
  receiving updates from us.

* **Recipient Authentication**: This describes how we know that we are still
  sending updates to the expected recipient.

* **Encryption**: This describes how messages are encrypted while in transit
  from the sender to the recipient.

Many 

[[!toc]]

# remctl

remctl is a client, server, and protocol that provides for simple
request-response communication.  It was developed at Stanford University by
Anton Ushakov, and today is maintained outside of Stanford by Russ Allbery,
with contributions from Stanford and elsewhere.

## Protocol Description

Delivering a change notification only requires two parties: WGLURP, which is
acting as a _remctl client_; and the receiving server, which is acting here
also as a _remctl server_.

To deliver a change notification, WGLURP opens a connection directly to the
receiving server.  This means that either the receiving server must have a
publicly-routable IP address, or must be behind some sort of proxy (for
example, a load-balancer).

Once the connection is opened, both ends of the connection use GSSAPI/Kerberos
to establish mutual authentication, confidentiality (that is, encryption), and
integrity protection for the connection.  Once this process is complete, the
_remctl client_ sends its request.  Each request consists of a _command_, a
_sub-command_, and zero or more _arguments_.  Once the request has been
received, the _remctl server_ uses the client's identity and its own
configuration to determine if it should allow the request to go through.

Notwithstanding additional limits imposed by server implementations, the remctl
protocol allocates 32 bits for the 'number of arguments' (two of which are
consumed by the command and sub-command), and each argument's length is also
limited to 32 bits.  This allows for each of the command, sub-command, and up
to 2^32-3 arguments to be almost 4 GB long.  That said, the reference remctl
server implementation limits each argument to 64 kilobytes.

## Message Format

Change notifications sent using remctl take full advantage of its command and
sub-command formst.  For WGLURP, the command is always `wglurp`, and the
sub-command will be either `add`, `remove`, or `sync`.

The `add` sub-command means that one or more users are being added to a group;
the `remove` sub-command means that one or more users are being removed from a
group.  The first argument contains the name of the group, UTF-8 encoded.  The
second argument is a JSON list of users being added or removed.

For the JSON list, each list entry is itself a list.  So, for the `add` and
`remove` sub-commands, the second argument contains a JSON list of lists.  Each
'inner list' contains two items.  The first 'inner list' item is the user's
unique ID; the second 'inner list' item is the user's username.

For the `sync` sub-command, five arguments are used.  The first argument
is—just like with `add` and `remove`—the name of the group being synced.
The second through fifth arguments are (respectively)…

* The list hash, as a string of 32 hex characters.
* The access ID, an integer sent as an ASCII string (so, for example, the number ten
  is sent as the string "10").
* The secret key, as a string of 32 hex characters.
* The expiration date, a UNIX timestamp (that is, seconds since January 1,
  1970 in the UTC time zone), which an integer sent as an ASCII string.



## Authentication

Because this delivery method uses a direct connection between sender and
recipient, the parties are able to directly authenticate each other, instead of
relying on a challenge, or a message signature.  The contents of Challenges and
Signatures are not used here.  Instead, Kerberos is used for authentication.

Kerberos is similar to TLS in that both ends of the connection trust a
third-party authority (in Kerberos terminology, the _Key Distribution Center_, or _KDC_).  Unlike TLS, however, KDCs are usually located within the organization.

When the remctl client (in this case, the sender, WGLURP) wishes to connect to the remctl server (the recipient), we first obtain a _ticket_ from the KDC.  Among other things, the ticket includes…

* A session key, 
* An encrypted message, that only the remctl server can decrypt; and
* An expiration date.

The session key is also included in the encrypted message.

Once the remctl client has obtained a ticket, it provides this ticket to the
remctl server; along with the current time, encrypted using the session key.
The remctl server decrypts the ticket-embedded message, from which it obtains
the session key.  If the remctl server is able to decrypt the session
key-encrypted time sent by the remctl client, and the time is not too far
different from the current time, then the remctl client has been authenticated.

To authenticate the remctl server, the remctl server takes the timestampt sent
by the remctl client, increments it by one, and encrypts the result with the
session key, which the remctl server then sends back to the remctl client.
Once the remctl client receives, decrypts, and verifies the returned
timestamp-plus-one, the remctl server has been authenticated.

For a full description of this authentication, see RFC 4120 Section 3.2.

## Encryption

The Kerberos protocol provides content encryption and integrity protection as
optional services.  remctl makes use of these services by default.  The
encryption and message integrity algorithms used for the connection are
set by the KDC at the time it issues a ticket, and the encryption key used for
the connection will either be the session key generated by the KDC, or a
new key (known as the _sub-key_) chosen by the client.

For example, at the time of writing, most environments are using the CBC+CTS
mode of AES, with 256-bit keys, for encryption; and HMAC for message integrity,
using the SHA-1 hash, and taking only 96 bits of the HMAC output.

> **Convention**: WGLURP will only use the `aes256-cts-hmac-sha1-96` encryption
> type.

For a full description of message encryption and integrity protection, see RFC
4120 Sections 3.4 (for encryption) and 3.5 (for integrity protection).  For
details of AES and SHA-1 usage in Kerberos, see RFC 3962.

# SQS

# SNS

# Webhook

# Websockets
